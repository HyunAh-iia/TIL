# Learning PHP (OReilly)
Learning PHP를 읽으며 내가 기존에 알던 언어들과 PHP의 다른 규칙, 낯선 개념, 유의해야할 점들을 위주로 요약하였음.

## 1. 오리엔테이션과 첫걸음
- 함수의 대소문자 구별이 없으나 변수는 대소문자 구분 있
- Here Document(Here 문서) <<<_HTML_, _HTML_
- PHP 영역 선언 : <php? , ?> 의 조합. 약어로 <?, ?>를 사용할 수 있으나, 이를 인식하지 못하는 서버가 있을 수 있으므로 축약 지양
- 주석 스타일 : #, //, /**/
- php는 서버 사이드에서 동작하는 스크립트 언어

## 2. 데이터: 텍스트와 숫자 다루기
- php 문자열의 크기는 컴퓨터 메모리 크기로 제한
- php 문자열은 글자가 아니라 바이트의 나열 (20장 내용 참고)
- 작은따옴표(')와 큰따옴표(") 차이 : 큰따옴표 내 변수명은 값으로 대치됨. 또한 `\n`, 8진수, 16진수와 같은 표현 가능.
- here 문서(<<<)의 시작은 알파벳이나 밑줄(_)만 가능
- 마침표(.)는 두 문자열 연결 연산자로 사용됨
- here 문서(큰따옴표 동작과 유사)와 달리 now 문서(작은따옴표 동작과 유사)는 변수 치환 기능 없음
- 문자열 내 변수 삽입 시 명확하게 영역을 구분짓기 위해 중괄호({}) 사용. ex) `"안녕? 나는 {$name}이야.`

## 3. 로직: 조건 판단과 반복 수행
- 논리식 거짓 : false, null, 0, 0.0, ''(공백), '0'(문자열 0)
- 부동소수점 비교 시 허용 오차 범위 (0.00001) 내 차이는 동등하다고 판단함 (abs() 활용)
- 비교 연산자(<, >) : 숫자는 문자열이어도 숫자 비교, 그 외는 문자 사전순으로 비교
- strcmp() : 왼쪽 값이 작으면 음수, 동등하면 0, 크면 양수 반환, 어떤 문자열이든 사전 순서대로 크기 비교(숫자 캐스팅 X)
- 우주선 연산자(<=>) : 왼쪽 값이 작으면 음수, 동등하면 0, 크면 양수 반환, 숫자 문자열은 숫자로 비교
- 문자열과 숫자의 비교 ( `비교 연산자(<, >)`, `strcmp()`, `우주선 연산자(<=>)` )  

   |구분|비교연산자(<,>)|strcmp()|우주선연산자(<=>) (php 7+)|결과값|
   |---|---|---|---|---|
   |문자 vs 문자|"x12345" < "x567"|strcmp("x12345","x567") < 0|"x12345" <=> "x567" < 0|true|
   |문자열 숫자 vs 문자열 숫자|"12345" > "567"|strcmp("12345","657") < 0|"12345" <=> "567" > 0|true|
   |혼용 vs 혼용|"6 pack" > "55 card"|strcmp("6 pack","55 card") > 0|"6 pack" <=> "55 card" > 0|true|
   |혼용 vs 숫자|"6 pack" < 55|strcmp("6 pack", 55) > 0|"6 pack" <=> 55 < 0|true|
   
- 알파벳 외 문자를 크기 비교할 경우, 인코딩에 따라 선후 관계가 변할 수 있으므로 지양
- php 문자열은 바이트의 나열이라는 것을 명심. 20.2절에 다양한 문자열 집합을 비교하고 정렬할 수 있는 `Collator 클래스` 안내

## 4. 데이터 집합: 배열 다루기
##### 배열 선언 및 할당
- 배열 : key와 value로 구성, key는 스칼라 값만 가능
- 배열 선언 : `$vegetables = array('corn'=>'노랑', 'beet'=>'빨강')` 혹은 단축 배열(php 5.4+)로 표현 `$vegetables = ['corn'=>'노랑', 'beet'=>'빨강']`, `$vegetables['corn'] = '노랑';`
- 배열 재할당 : 배열에 스칼라값 할당 시 배열변수는 스칼라변수로 변경된다. 스칼라 변수를 다시 배열 변수로 덮어씌우려면 `array()` 구문을 써야함. `$스칼라변수['key'] = value` 는 php 엔진 경고만 발생시키고 기존 스칼라값으로 유지된다. (배열 안먹음) => 이건 아마.. 배열 변수는 배열 클래스(?)를 상속한 객체인데 스칼라 변수는 그냥 값을 나타내는거니까 변수[key] = value 형태가 안먹는거겠지? // TODO 확인 필요
- 숫자키 배열 : 숫자키로 이루어진 배열은 key 축약 가능 => `$dinner = array('밥','김치');` 
- php 엔진은 숫자 키 배열과 문자열 키 배열을 내부적으로 각각 다르게 처리함. 그래서 숫자키 배열은 인덱스배열, 순차배열이라고도 말하고, 문자열키 배열은 연관 배열이라고도 함
- 배열 제거 : `unset()`

##### 배열 순회
- 배열 순회 : `foreach()`, `for()`. 별칭으로 생성된 변수는 해당 구문 내에서만 유효하며 각 배열의 원소값이 복사됨
- 배열 순회 시 `foreach()`는 배열이 추가된 순서로 출력하므로, 인덱스 순으로 순회를 원한다면 for()를 사용해야함 (js forEach는 인덱스 순으로 순회)

##### 배열 키/값 존재여부 확인
- 배열 키 존재여부 : `array_key_exists('key', $array_name);`
- 배열 원소값 존재여부 : `in_array(value, $array_name);` (대소문자 구분하며 반환값 true/false)
- 배열 원소값의 키 : `array_search(value, $array_name)` 원소의 키값 반환

##### 배열 표시 및 변환
- 문자열이나 here 문서 내 배열 원소를 표시할 때 : `$array_name[key]`와 같이 키 값에 따옴표를 감싸지 않는다. 단, 키 값에 화이트스페이스나 문장기호 등이 포함되었을 경우 중괄호로 감싼다. `{$array_name['My Key']}`
- 배열 to 문자열 : `implode()` ex) print implode(',', $array_name); // 원소값1, 원소값2, 원소값3
- 문자열 to 배열 : `explode()` ex) $array_name = explode(',', 'A, B, C'); // [A, B, C];

##### 배열 정렬
- `sort()` : 원소값을 기준으로 재정렬됨. 연관배열(문자열 키)은 sort() 적용 시 키 값이 숫자로 변경됨
- `asort()` : 키 변경 없이 연관배열을 원소값 정렬하려면 `asort()`를 사용 => 숫자키 정렬 시 index가 0, 2, 1 이런 순으로 바뀔 수 있겠군 //TODO 확인
- `ksort()` : 키 기준으로 정렬. 인덱스 배열의 순서가 0, 2, 1 이렇게 되어있다면 0, 1, 2로 재정렬되겠지? //TODO 확인
- 내림차순은 각 정렬함수에 `r`을 추가하면 됨 : `rsort(), arsort(), krsort()`

##### 다차원 배열
- 다차원 배열 할당 1 : `$meals = array('breakfast' => ['우유', '콘푸라스트']);`)
- 다차원 배열 할당 2 : `$breakfast = [['우유', '콘푸라스트]];`)
- 다차원 배열 할당 3 : `$meals = array('breakfast' => array('우유', '콘푸라스트'));`)