# Learning PHP (OReilly)
Learning PHP를 읽으며 내가 기존에 알던 언어들과 PHP의 다른 규칙, 낯선 개념, 유의해야할 점들을 위주로 요약하였음.

## 1. 오리엔테이션과 첫걸음
- 함수의 대소문자 구별이 없으나 변수는 대소문자 구분 있
- Here Document(Here 문서) <<<_HTML_, _HTML_
- PHP 영역 선언 : <php? , ?> 의 조합. 약어로 <?, ?>를 사용할 수 있으나, 이를 인식하지 못하는 서버가 있을 수 있으므로 축약 지양
- 주석 스타일 : #, //, /**/
- php는 서버 사이드에서 동작하는 스크립트 언어

## 2. 데이터: 텍스트와 숫자 다루기
- php 문자열의 크기는 컴퓨터 메모리 크기로 제한
- php 문자열은 글자가 아니라 바이트의 나열 (20장 내용 참고)
- 작은따옴표(')와 큰따옴표(") 차이 : 큰따옴표 내 변수명은 값으로 대치됨. 또한 `\n`, 8진수, 16진수와 같은 표현 가능.
- here 문서(<<<)의 시작은 알파벳이나 밑줄(_)만 가능
- 마침표(.)는 두 문자열 연결 연산자로 사용됨
- here 문서(큰따옴표 동작과 유사)와 달리 now 문서(작은따옴표 동작과 유사)는 변수 치환 기능 없음
- 문자열 내 변수 삽입 시 명확하게 영역을 구분짓기 위해 중괄호({}) 사용. ex) `"안녕? 나는 {$name}이야.`

## 3. 로직: 조건 판단과 반복 수행
- 논리식 거짓 : false, null, 0, 0.0, ''(공백), '0'(문자열 0)
- 부동소수점 비교 시 허용 오차 범위 (0.00001) 내 차이는 동등하다고 판단함 (abs() 활용)
- 비교 연산자(<, >) : 숫자는 문자열이어도 숫자 비교, 그 외는 문자 사전순으로 비교
- strcmp() : 왼쪽 값이 작으면 음수, 동등하면 0, 크면 양수 반환, 어떤 문자열이든 사전 순서대로 크기 비교(숫자 캐스팅 X)
- 우주선 연산자(<=>) : 왼쪽 값이 작으면 음수, 동등하면 0, 크면 양수 반환, 숫자 문자열은 숫자로 비교
- 문자열과 숫자의 비교 ( `비교 연산자(<, >)`, `strcmp()`, `우주선 연산자(<=>)` )  

   |구분|비교연산자(<,>)|strcmp()|우주선연산자(<=>) (php 7+)|결과값|
   |---|---|---|---|---|
   |문자 vs 문자|"x12345" < "x567"|strcmp("x12345","x567") < 0|"x12345" <=> "x567" < 0|true|
   |문자열 숫자 vs 문자열 숫자|"12345" > "567"|strcmp("12345","657") < 0|"12345" <=> "567" > 0|true|
   |혼용 vs 혼용|"6 pack" > "55 card"|strcmp("6 pack","55 card") > 0|"6 pack" <=> "55 card" > 0|true|
   |혼용 vs 숫자|"6 pack" < 55|strcmp("6 pack", 55) > 0|"6 pack" <=> 55 < 0|true|
   
- 알파벳 외 문자를 크기 비교할 경우, 인코딩에 따라 선후 관계가 변할 수 있으므로 지양
- php 문자열은 바이트의 나열이라는 것을 명심. 20.2절에 다양한 문자열 집합을 비교하고 정렬할 수 있는 `Collator 클래스` 안내

## 4. 데이터 집합: 배열 다루기
##### 배열 선언 및 할당
- 배열 : key와 value로 구성, key는 스칼라 값만 가능
- 배열 선언 : `$vegetables = array('corn'=>'노랑', 'beet'=>'빨강')` 혹은 단축 배열(php 5.4+)로 표현 `$vegetables = ['corn'=>'노랑', 'beet'=>'빨강']`, `$vegetables['corn'] = '노랑';`
- 배열 재할당 : 배열에 스칼라값 할당 시 배열변수는 스칼라변수로 변경된다. 스칼라 변수를 다시 배열 변수로 덮어씌우려면 `array()` 구문을 써야함. `$스칼라변수['key'] = value` 는 php 엔진 경고만 발생시키고 기존 스칼라값으로 유지된다. (배열 안먹음) => 이건 아마.. 배열 변수는 배열 클래스(?)를 상속한 객체인데 스칼라 변수는 그냥 값을 나타내는거니까 변수[key] = value 형태가 안먹는거겠지? // TODO 확인 필요
- 숫자키 배열 : 숫자키로 이루어진 배열은 key 축약 가능 => `$dinner = array('밥','김치');` 
- php 엔진은 숫자 키 배열과 문자열 키 배열을 내부적으로 각각 다르게 처리함. 그래서 숫자키 배열은 인덱스배열, 순차배열이라고도 말하고, 문자열키 배열은 연관 배열이라고도 함
- 배열 제거 : `unset()`

##### 배열 순회
- 배열 순회 : `foreach()`, `for()`. 별칭으로 생성된 변수는 해당 구문 내에서만 유효하며 각 배열의 원소값이 복사됨
- 배열 순회 시 `foreach()`는 배열이 추가된 순서로 출력하므로, 인덱스 순으로 순회를 원한다면 for()를 사용해야함 (js forEach는 인덱스 순으로 순회)

##### 배열 키/값 존재여부 확인
- 배열 키 존재여부 : `array_key_exists('key', $array_name);`
- 배열 원소값 존재여부 : `in_array(value, $array_name);` (대소문자 구분하며 반환값 true/false)
- 배열 원소값의 키 : `array_search(value, $array_name)` 원소의 키값 반환

##### 배열 표시 및 변환
- 문자열이나 here 문서 내 배열 원소를 표시할 때 : `$array_name[key]`와 같이 키 값에 따옴표를 감싸지 않는다. 단, 키 값에 화이트스페이스나 문장기호 등이 포함되었을 경우 중괄호로 감싼다. `{$array_name['My Key']}`
- 배열 to 문자열 : `implode()` ex) print implode(',', $array_name); // 원소값1, 원소값2, 원소값3
- 문자열 to 배열 : `explode()` ex) $array_name = explode(',', 'A, B, C'); // [A, B, C];

##### 배열 정렬
- `sort()` : 원소값을 기준으로 재정렬됨. 연관배열(문자열 키)은 sort() 적용 시 키 값이 숫자로 변경됨
- `asort()` : 키 변경 없이 연관배열을 원소값 정렬하려면 `asort()`를 사용 => 숫자키 정렬 시 index가 0, 2, 1 이런 순으로 바뀔 수 있겠군 //TODO 확인
- `ksort()` : 키 기준으로 정렬. 인덱스 배열의 순서가 0, 2, 1 이렇게 되어있다면 0, 1, 2로 재정렬되겠지? //TODO 확인
- 내림차순은 각 정렬함수에 `r`을 추가하면 됨 : `rsort(), arsort(), krsort()`

##### 다차원 배열
- 다차원 배열 할당 1 : `$meals = array('breakfast' => ['우유', '콘푸라스트']);`)
- 다차원 배열 할당 2 : `$breakfast = [['우유', '콘푸라스트]];`)
- 다차원 배열 할당 3 : `$meals = array('breakfast' => array('우유', '콘푸라스트'));`)

## 5. 논리 집합: 함수와 파일
##### 함수 선언과 호출
- 함수 선언 : `function 함수명() { }`
- 함수명 : 첫 글자는 문자나 밑줄문자로 시작해야하며, 동일 이름의 변수가 존재해도 구분 가능.
- 함수의 순서 : PHP 엔진이 전체 프로그램 파일을 읽으며 모든 함수를 인지한 뒤에 명령을 실행하기 떄문에 호출 뒤에 함수 선언이 와도 괜찮음
##### 함수 인수 전달
- 인수 기본값 설정 : `function print_color($color = 'red') { }`
- 인수 기본값에 변수 사용 불가 : `function print_color($color = $red) { }` 불가 => PHP엔진이 함수를 읽어들이는 시점 이후에 인수의 변수값이 동적으로 변경될 수 있으니까 불가하도록 했겠지? 함수를 읽어들인 후 이 함수를 식으로서 관리하는걸까?
- PHP 엔진이 인수로 전달한 값을 인수 변수에 복사하기 때문에, 함수 외부 변수는 영향을 받지 않음 
##### 반환값
- ```php
  function restaurant_check($base_price, $tax = 0.1) {
      $total = $base_price + ($base_price * $tax);
      return $total;
  }
  ```
##### 변수 영역
- 전역 변수 : 함수 밖에서 정의된 변수
- 지역 변수 : 함수 내부에 정의된 변수
- 함수 내부에서 전역 변수에 접근하는 방법은 두 가지
    - `$GLOBALS` 이라는 특수 배열 활용 : `print $GLOBALS['변수명'];`
    - `global` 키워드 사용 : `global $변수명;`을 선언 후에는 `$변수명`는 전역변수를 가르킨다.
- 일반적으로 전역변수 접근 시 `$GLOBALS` 변수를 사용함 : 코드의 명료성
- `$GLOBALS` : 자동 전역 변수라고도 한다. 영역에 관련된 아무런 조치 없이도 PHP 내 어디서든 사용 가능함. 자동 전역변수에 대해서는 7장, 10장에서 알아봄
##### 인수와 반환값 제한
- 형 선언을 통해 함수의 인수를 제한할 수 있음 (괄호는 지원되는 PHP 버전 의미) : ex) `function 함수명(int $number) { }`
    - array (5.1+)
    - bool (7.0+)
    - callable (5.4+) : 함수 또는 호출 가능한 메서드
    - float (7.0+)
    - int (7.0+)
    - string (7.0+)
    - 클래스명 (5.0+) : 해당 클래스의 인스턴스
- 반환값 제한 : ex) `function 함수명() : int { return 0; }`
- PHP 7의 기본설정은 스칼라 형의 선언을 완전 강제하지 않음 => 선언된 형과 일치하지 않으면 PHP 7은 형 변환을 시도함.
- 파일 맨 위에 `declare(strict_types = 1);` 구문을 넣어 느슨한 기본 설정을 엄격하게 변경 가능 (근데 전역 설정은 불가함. 적용하려는 파일마다 선언해야함;)
##### 다른 파일의 코드 실행
- `require` 구문 : 불러온 PHP 코드가 올바르지 않다면 PHP 엔진은 프로그램 실행 중단
- `include` 구문 : 불러온 코드가 올바르지 않더라도 프로그램 계속 실행

## 6. 데이터와 로직: 객체 다루기
##### 클래스
- 객체 내부 속성이나 메서드 가르키기 : 화살표 지시자(`->`) 사용 (배열 지시자 `=>`와는 다름)
- `$this` : 인스턴스를 가르킴
- 정적메서드는 클래스를 통해 접근하며 지시자는 `->` 대신 `::` 를 사용
- 클래스 생성자명은 항상 `__construct()` 
- 클래스 상속 시 생성자도 포함하여 다 상속받음
- 부모 클래스의 생성자 명시적 실행 `parent::__construct()` // TODO parent가 부모 객체를 가르키는데, 왜 $ 연산자가 없을까? 무슨 차이인지 확인
- 클래스의 객체여부 판별 : `타겟 instanceof 클래스명`

##### 네임스페이스 (PHP 5.4+)
- 네임스페이스에 익숙해지면 타인이 작성한 패키지를 자신의 프로그램으로 가져올 수 있음. 자세한 내용은 16장 컴포저 패키지 관리 시스템 참고
- 네임스페이스란 클래스 정의나 다르 네임스페이스를 포함하는 컨테이너.
- `namespace` 키워드나 클래스명에 역슬래시(`\`) 가 있으면 네임스페이스가 사용된 코드
- 클래스에 네임스페이스가 없을 경우 디폴트는 최상위 네임스페이스인 루트(`\`)로 지정
- 최상위 네임스페이스 클래스를 참조할 때는 혼동의 여지를 없애기 위해 명시적으로 `\`를 클래스명 앞에 붙이기를 권장 //TODO ?? 네임스페이스의 실 사용예제를 봐야 이해갈 듯
- 네임스페이스 작성을 단순화하기 위해 `use` 키워드 제공 (별칭이 없으면 맨마지막 클래스명을 별칭으로 인식)
