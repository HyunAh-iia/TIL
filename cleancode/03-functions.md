# 함수
## 책에서 기억하고 싶은 내용
어떤 프로그램이든 가장 기본적인 단위가 함수다.
의도를 분명히 표현하는 함수는 읽기 쉽고 이해하기 쉽다.
함수에 어떤 속성을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있을까?
### 작게 만들어라
- 함수가 작을수록 더 좋다는 증거나 자료를 제시하기 어려우나, 저자는 그 동안의 경험과 오랜 시행착오를 바탕으로 작은 함수가 좋다고 확신한다
- if문, else문, while문 등에 들어가는 블록은 한 줄이어야 한다
  - 대개 여기서 함수를 호출한다. 그러면 바깥을 감싸는 함수가 작아질 뿐 아니라 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워짐
  - 이 말은 중첩 구조가 생길만큼 함수가 커져서는 안된다는 뜻임
### 한 가지만 해라
- '한 가지'라는 무엇인가?
- 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.
- 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다. [G34]
### 함수 당 추상화 수준은 하나로
- 함수 내 모든 문장의 추상화 수준이 동일해야한다.
- 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어려운 탓이다. 근본개념과 세부사항이 뒤섞이기 시작하면 깨어진 창문처럼 사람들이 함수에 세부사항을 점점 더 추가한다.
- 위에서 아래로 코드 읽기: 내려가기 규칙
  - 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.
### Switch 문
- swtich 문을 저차원 클래스에 숨기고 다형성을 이용한다
- 일반적으로 저자는 다형적 객체를 생성하는 코드 안에서만 switch 문을 단 한번만 허용한다고 한다. 상속관계로 숨긴 후 절대로 다른코드에 노출하지 안흔ㄴ다. ([G23] 물론 불가피한 경우도 생긴다)
### 서술적인 이름을 사용하라
- 길고 서술적인 이름이 짧고 어려운 이름보다 좋고, 서술적인 주석보다 좋다.
- 이름을 붙일 때는 일관성이 있어야한다. 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다. 문체가 비슷하면 이야기를 순차적으로 풀어가기도 쉬워진다.
### 함수 인수
- 함수에서 이상적인 인수 개수는 0개, 그 다음은 1개, 그 다음은 2개다. 3개 이상은 가능한 피하는 편이 좋다. 4개 이상은 특별한 이유가 필요하다. 특별한 이유가 있어도 사용하면 안된다.
- 함수 이름과 인수 사이에 추상화 수준이 다르다. 게다가 코드를 읽는 사람이 현 시점에서 별로 중요하지 않는 세부사항을 알아야한다.
- 테스트 관점에서 보면 인수는 더 어렵다.
- 많이 쓰는 단항 형식은 두 가지다. 함수 이름을 지을 때는 두 경우를 분명히 구분한다. 또 언제나 일관적인 방식으로 두 형식을 사용한다. (56 명령과 조회를 분리하라 참조)
  1. 인수에 질문을 던지는 경우
  2. 인수를 뭔가로 변환해 결과를 반환하는 경우
  3. 그리고 드물지만 이벤트 함수도 있다. 입력 인수만 있고 출력 인수는 없다.
- 입력 입수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다 (void 대신 출력을 명시하라는 뜻)
- 플래그 인수는 추하다. 
- 인수가 2개인 함수(이항 함수)는 1개인 함수보다 이해하기 어렵다. 물론 좌표를 표현할 때처럼 이항 함수가 적절한 경우도 있다.
  - 흔히 사용되는 assertEquals(exptected, actual)도 문제가 있다. 두 인수는 자연적인 순서가 없다. 이 메서드를 사용할 때 인수의 순서를 외워야한다.
- 인수가 2~3개 필요하다면 일부를 독자적인 클래스 변수로 선언이 가능한지 되짚어보자
  - 두 인수가 밀접한 관계라면 하나의 개념으로 묶어서 표현한다
### 부수 효과를 일으키지 마라
- 일반적으로 인수를 함수의 입력으로 해석하기 때문에 이 함수(`public void appendFooter(StringBuffer report`)는 어색하게 느껴진다.(인수로 입력받은 변수에 이벤트를 가하는 게 어색하다는 뜻임). 객체 지향 언어에서는 출력 인수를 사용할 필요가 거의 없다. 출력 인수로 사용하라고 설계한 벼수가 바로 `this` 이기 때문이다. 다시 말해 이런 식으로 호출하는게 좋다. `report.appendFooter()`
### 명령과 조회를 분리하라
- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야한다.
### 결론
- 모든 시스템은 특정 응용 분야 시스템을 기술할 목적으로 프로그래머가 설계한 도메인 특화 언어(Domain Specific Language, DSL)로 만들어진다. 함수는 그 언어에서 동사며, 클래스는 명사다.


## 소감
일단 존버하면서 좀 더 읽어보겠다..

## 궁금한 것
- 한 가지 기능만 하는 `추상화`의 수준이나 범위는 어떻게 잡아야하는걸까? 누군가에게는 여러 가지 일을 한번에 하는 메서드로 보일 수도, 누군가에게는 하나의 추상화 기능을 수행하는 메서드로 보일 수도 있겠다. 심지어 도메인에 따라서도 이 범위가 달라질 수도 있겠을텐데 추상화 기준을 어떻게 잡아야할까? 책에서 설명이 되어 있지만 스스로에게 충분한 설명이 되지 않았다.
- SPR(Single Responsibility Principle)
  - [위키백과 - 단일 책임 원칙](https://ko.wikipedia.org/wiki/%EB%8B%A8%EC%9D%BC_%EC%B1%85%EC%9E%84_%EC%9B%90%EC%B9%99) : 모든 클래스는 하나의 책임만 가지며 클래스가 제공하는 모든 기능은 이 책임과 주의 깊게 부합해야 함
  - [위키백과 - SOLID 객체 지향 설계](`https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)`)
  - [Patkos Csaba: 	
SOLID: Part 1 - The Single Responsibility Principle](https://code.tutsplus.com/ko/tutorials/solid-part-1-the-single-responsibility-principle--net-36074)
  - [Baeldung - Single Responsibility Principle in Java](https://www.baeldung.com/java-single-responsibility-principle)
- OCP(Open Closed Principle) : todo
  - [위키백과 - 개방 폐쇄 원칙](https://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99) : 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다'는 프로그래밍 원칙임. 개방-폐쇄 원칙이 잘 적용되면, 기능을 추가하거나 변경해야 할 때 이미 제대로 동작하고 있던 원래 코드를 변경하지 않아도, 기존의 코드에 새로운 코드를 추가함으로써 기능의 추가나 변경이 가능함. 확장에 대해 열려 있고 수정에 대해 닫혀있음
  - [Baeldung - Open/Closed Principle in Java](https://www.baeldung.com/java-open-closed-principle)
  - [Patkos Csaba - SOLID: Part 2 - The Open/Closed Principle](https://code.tutsplus.com/tutorials/solid-part-2-the-openclosed-principle--net-36600)

